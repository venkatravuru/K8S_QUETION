🔹 Scenario 1: Pod in CrashLoopBackOff

✅ Use Case: Your application Pod keeps restarting right after it starts.

❓ Interview Question: You deployed a Pod, but it's stuck in CrashLoopBackOff. What steps do you take to troubleshoot and fix it?

💡 Answer: Check Pod logs:

bash Copy Edit kubectl logs Check if it’s a config issue: Missing env vars, DB unreachable, crash in startup script.

Describe the Pod to view events:

bash Copy Edit kubectl describe pod Check liveness probe settings — it may be killing the container too early.

Fix the root issue, update the YAML, and reapply.

🔹 Scenario 2: Pod Stuck in Pending State

✅ Use Case: You created a Pod, but it's stuck in Pending for several minutes.

❓ Interview Question: A Pod is not scheduling and remains in Pending. What could be causing this, and how would you resolve it?

💡 Answer: Describe the Pod:

bash Copy Edit kubectl describe pod Common causes:

Insufficient node resources (CPU/Memory)

PVC not bound

No matching Tolerations / Affinity issues

Fix it:

Adjust resource requests or limits

Scale the cluster

Modify affinity or taints/tolerations

🔹 Scenario 8: Pod Can't Pull Image from Private Registry

✅ Use Case: Your Pod fails with ImagePullBackOff.

❓ Interview Question: What steps would you take if your Pod can’t pull an image from a private registry?

💡 Answer: Create a secret with your registry credentials:

bash Copy Edit kubectl create secret docker-registry my-reg-secret
--docker-username= --docker-password= --docker-server= Reference it in the Pod spec:

yaml Copy Edit imagePullSecrets:

name: my-reg-secret
🔹 Scenario 9: Sidecar Container to Process Shared Data

✅ Use Case: You want a second container to process files written by the main app.

❓ Interview Question: How can two containers in the same Pod share data?

💡 Answer: Use emptyDir volume:

yaml Copy Edit volumes:

name: shared emptyDir: {}
containers:

name: main volumeMounts:
name: shared mountPath: /data
name: sidecar volumeMounts:
name: shared mountPath: /data Both containers can read/write to /data.
🔹 BONUS: Multi-Container Pod Interview Question ❓ How are multi-container Pods useful? Give a real-world use case. 💡 Answer: Use Case: One container runs the app, another logs or watches files.

Example: App writes logs → Sidecar ships them to Fluentd.

Another: App exposes metrics → Sidecar collects and exposes via Prometheus.

🔹 Scenario 11: Pod with High CPU Usage Under Load ❓ Question: Your application Pod consumes too much CPU under load. How do you prevent it from affecting other Pods on the same node?

💡 Answer: Use CPU limits in the Pod spec:

yaml Copy Edit resources: requests: cpu: "250m" limits: cpu: "500m" This ensures the Pod doesn’t use more than 500m (0.5 CPU).

If the app still needs more, use HPA to scale out instead of increasing CPU limits.

Scenario 12: App Gets Killed by OOM (Out of Memory) ❓ Question: How do you prevent your application from being OOMKilled?

💡 Answer: Use memory limits:

yaml Copy Edit resources: requests: memory: "256Mi" limits: memory: "512Mi" Monitor app usage and set realistic memory requests and limits.

Investigate memory leaks in the app if it grows uncontrollably.

Scenario 13: Pod Health Checks Are Failing ❓ Question: What types of health checks does Kubernetes support for Pods, and how are they different?

💡 Answer: Kubernetes supports 3 types of probes:

Liveness Probe – checks if the app should be restarted.

Readiness Probe – checks if the app is ready to serve traffic.

Startup Probe – waits for the app to start before applying other probes.

Use:

yaml Copy Edit readinessProbe: httpGet: path: /ready port: 8080

🔹 Scenario 14: Need to Debug a Running Pod
❓ Question: How can you troubleshoot a running Pod if you can't SSH into it?

💡 Answer: Use kubectl exec to run a command inside the Pod:

bash Copy Edit kubectl exec -it -- /bin/sh If no shell is available, run a debug container:

bash Copy Edit kubectl debug -it --image=busybox --target=

🔹 Scenario 15: Need to Restart a Single Pod ❓ Question: How do you restart a specific Pod?

💡 Answer: Pods can't be restarted directly (stateless). Instead:

bash Copy Edit kubectl delete pod The Deployment or ReplicaSet will create a new one automatically.

Scenario 16: Pod Lifecycle Management ❓ Question: What are the lifecycle states of a Kubernetes Pod?

💡 Answer: Pending: Pod accepted but not running yet

Running: Pod is up and containers are running

Succeeded: Pod completed (for jobs)

Failed: Pod terminated with failure

Unknown: Node not reachable

Use kubectl get pod -o wide or kubectl describe pod to check status.

🔹 Scenario 17: Deploy a
